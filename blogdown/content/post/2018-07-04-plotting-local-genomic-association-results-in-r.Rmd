+++
title = "Plotting Local Genomic Association Results in R"
description = ""
author = ""
date = 2018-07-04T10:43:44+02:00
tags = ["statgen", "R", "data visualisation", "R", "ggplot2"]
category = ["statgen", "R", "data visualisation"]
draft = true
+++

<!-- what will I do? -->

In this blogpost, I will show how to zoom into GWAS results and annotate the plot based on the information about that genomic region --- with R and another specialised software.

<!-- reasoning: why do we need a locus zoom plot -->



<!-- data -->
## Get summary statistics

For this we need first some summary association statistics. 

There are lots of [ressources](https://github.com/sinarueeger/statistical-genetics-resources/blob/master/statgen-data.md#gwas-summary-statistic-results) for publicly available GWAS summary association statistics. Recently, there have been two new studies on [SCZ and BD](https://www.sciencedirect.com/science/article/pii/S0092867418306585?via%3Dihub), as well as [Major depressive disorder (MDD)](https://www.nature.com/articles/s41588-018-0090-3). For all studies of PGC, summary statistics can be downloaded [here](https://www.med.unc.edu/pgc/results-and-downloads/downloads). For MDD thats search for 'MDD2 2018' and  for BD and SCZ 'BIP and SCZ results from Cell Publication, 2018'. Note, that you need to agree to conditions. 

Because direct download is not possible, we will look at another great source, GIANT. BMI. Download [here](https://portals.broadinstitute.org/collaboration/giant/index.php/GIANT_consortium_data_files#GWAMA_Age-.2FSex-Stratified_2015_BMI_and_WHR) from this [publication](https://www.biorxiv.org/content/early/2018/03/22/274654).

```{r, setup, warning=FALSE,message=FALSE}
## we are gonna need this
library(tidyverse)
library(cookbookRsina) ## for QQPLOT

```

```{r, echo=TRUE, results="hide", cache=TRUE, message = FALSE}

## bmi
dat.bmi <- read_tsv(file = "https://portals.broadinstitute.org/collaboration/giant/images/2/21/BMI_All_ancestry.fmt.gzip")

## Rename some columns
dat.bmi <- dat.bmi %>% rename(SNP = SNPNAME, P = Pvalue)

```

This dataset has `r nrow(dat.bmi)` rows and `r ncol(dat.bmi)` columns.

If we look at the first 3 rows, we can see that the first column indicates the chromosome, the econd the chromosomal position, the reference allele, the alternative allele, the SNP identifier, Minor allele frequencies measured in GIANT and ExAC, then the association of that SNP with BMI (beta, se, Pvalue). 

```{r, head}
head(dat.bmi, n = 3)
```

## Plot dataset

Since the datset is so large, we want to plot he Pvalues with a historgram. 

```{r, plotting, warning =FALSE,message=FALSE}
ggplot(data = dat.bmi) + geom_histogram(aes(-log10(P)))

```
The problem is, that the distribution is highly skewed, even when log transformed. The reason for this, is, that most pvalues are of course uniformly distributed, and only a few are hits. 

So a QQplot might suit better. 

```{r, qqplot}
QQplot(dat.bmi$P)

```

Now, we want to look at a specific genomic region and add annotation, so let's pick the genomic region with the lowest P-value.

```{r, min, warning =FALSE}
dat.bmi.min <- dat.bmi %>% slice(which.min(P))
dat.bmi.min
```

`r dat.bmi.min$SNP` is the SNP that has the lowest P-value. Next, we want to know if this SNP is part of a Gene, and if yes, which one. 

## Extracting annotation

There are plenty of websites to check this. But we love R, and we love to do things in a reproducible way, so lets tackle this with R. 

Thankfully, there is a library that can do this very efficiently for us. Here, we look at human data, but this library can acutally expand on any species. In fact, the library can do much much more, than I am going to show. So if, say, you are interested in the sequence of Drosophila, you better checkout this package. 

I learned this from here: 

- From: https://www.bioconductor.org/packages/devel/bioc/vignettes/biomaRt/inst/doc/biomaRt.html
- also checkout this: https://stackoverflow.com/questions/41490657/best-way-to-get-list-of-snps-by-gene-id

Before getting the gene name, I want to check if my chromosome and position in the dataset are actually matching with the info in the database. This is a handy thing, because oftentimes, only SNPs are reported. Or SNPs are reported, but on a different build. 


```{r, get-snp-chr-pos, include = TRUE}

library(biomaRt)

## snp human variation data
## -------------------------
variation <- useEnsembl(biomart="snp", dataset="hsapiens_snp")
out.bm <- getBM(attributes = c(
  "ensembl_gene_stable_id",
  'refsnp_id',
  'chr_name',
  'chrom_start',
  'chrom_end',
  'minor_allele',
  'minor_allele_freq'),
  filters = 'snp_filter',
  values =dat.bmi.min$SNP,
  mart = variation
)
out.bm

ifelse(dat.bmi.min$CHR == out.bm$chr_name, "chromosome matching", "chromosome is not matching")
ifelse(dat.bmi.min$POS == out.bm$chrom_start, "position matching", "position is not matching")

```

Next, we want to get the gene name. 

```{r, get-snp-info, include = TRUE}

## SNPMART
## ---------
snpmart = useMart(biomart = "ENSEMBL_MART_SNP", dataset="hsapiens_snp")


listAttributes(snpmart) %>% slice(str_which(description, "Gene")) 
listAttributes(variation) %>% slice(str_which(description, "Gene")) 

## extract gene-d
## ----------
out.bm.snpmart <- getBM(attributes = c('refsnp_id','allele','chrom_start','chrom_strand', 'chr_name', 'phenotype_description', 'ensembl_gene_stable_id','associated_gene'), 
      filters = c('snp_filter'), 
      values = dat.bmi.min$SNP, 
      mart = snpmart)
out.bm.snpmart

## extract name
## ----------
ensembl = useMart("ensembl",dataset="hsapiens_gene_ensembl")
out.bm.ensembl <- getBM(attributes = c('external_gene_name'), 
      filters = c('ensembl_gene_id'),
      values = unique(out.bm.snpmart$ensembl_gene_stable_id), 
      mart = ensembl)
out.bm.ensembl


```

The gene is called `r out.bm.ensembl$external_gene_name`. 


## Plot summary stats
```{r, prep.data, include = TRUE}

fto.chr <- dat.bmi.min$CHR
fto.pos <- dat.bmi.min$POS
range <- 250e3

dat.bmi.fto.region <- dat.bmi %>% filter(CHR == fto.chr & POS < (fto.pos + range) & POS > (fto.pos - range))

```


```{r, plot.summarystats, include = TRUE}

qplot(POS, -log10(P), data = dat.bmi.fto.region)

```


## Extract ALL gene names in the region
```{r, get-all-genes-in-range, include=TRUE, cache=TRUE}

listAttributes(ensembl) %>% slice(str_which(description, "Gene")) 
listFilters(ensembl)%>% slice(str_which(description, "Gene")) 
out.bm.genes.region <- getBM(attributes = c('start_position','end_position','ensembl_gene_id','external_gene_name'), 
      filters = c('chromosome_name','start','end'), 
      values = list(fto.chr,fto.pos - range, fto.pos + range), 
      mart = ensembl)
out.bm.genes.region

```


```{r, plot.genes, include = TRUE}

ggplot(data = out.bm.genes.region) + geom_linerange(aes(x = external_gene_name, ymin = start_position, ymax = end_position)) + coord_flip()

```


<!-- GWAS + biomart info -->
## R with origninal datasources

Plot it with original dataa 


## add Gtex summary stats




<!-- locuszoom -->
## Locuszoom

An easy solution is [LocusZoom](http://locuszoom.org/), a tool that takes SNPids and assocaiton summary stats as input and outputs a pretty graph, including gene annotation, LD information etc. 

The tool can be used via a web interface or command line tool. 


<!-- R + locuszoom -->
## R through locuszoomoutput

Plot it with data from locuszoom


<!-- tooling -->

## What plotting tools to use?

When doing more of what I like to call *arts & crafts* (plotting multiple datasets), it might be tempting to use base-R plotting functions. Simply because we are used to use base-R to overlay different datasets. 

But `ggplot2` can handle that probably better in the long run. 


<!-- other stuff -->

## Some other stuff



```{r, get-snp-info-pos-chr, include = TRUE, cache=TRUE, eval=FALSE}



## SNPMART
## ---------
snpmart = useMart(biomart = "ENSEMBL_MART_SNP", dataset="hsapiens_snp")

getBM(attributes = c('refsnp_id','allele','chrom_start','chrom_strand'), 
      filters = c('chr_name','start','end'), 
      values = list(8,148350,148612), 
      mart = snpmart)

```




```{r, get-gene-info, include = TRUE,cache =TRUE, eval=FALSE}

## first, we need to figure out the gene ID of FTO
ensembl = useMart("ensembl",dataset="hsapiens_gene_ensembl")
listFilters(ensembl)
gene.name.fto <- getBM(attributes = c('ensembl_gene_id'), 
      filters = c('external_gene_name'),
      values = "FTO", 
      mart = ensembl)
gene.name.fto

## Now we need to get the range of SNPs for that gene
snps.fto <- getBM(attributes = c( 'refsnp_id',
  'chr_name',
  'chrom_start',
  'chrom_end'), 
      filters = c('ensembl_gene'),
      values = gene.name.fto$ensembl_gene_id, 
      mart = variation)


```

```{r, get-all-snps-in-range, include=TRUE, cache=TRUE, eval=FALSE}

## SNPMART
## ---------
snpmart = useMart(biomart = "ENSEMBL_MART_SNP", dataset="hsapiens_snp")

out.bm.genes.region <- getBM(attributes = c('refsnp_id','allele','chrom_start','chrom_strand','ensembl_gene_stable_id'), 
      filters = c('chr_name','start','end'), 
      values = list(fto.chr,fto.pos - range, fto.pos + range), 
      mart = snpmart)

```